<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    </head>
    <body>
        <script>
            Object.prototype.contain = function (neddle) {
                for (let name in this) {
                    if (this[name] === neddle) {
                        return true;
                    }
                }
                return false;
            }
            let o = {
                'name': 'egoing',
                'city': 'seoul'
            }
            console.log(o.contain('egoing'));
            
             let a = ['egoing', 'leezche', 'grapittie'];  
            console.log(a.contain('leezche'));
            //그런데 Object 객체는 확장하지 않는 것이 바람직하다. 왜냐하면 모든 객체에 영향을 주기 때문이다. 
            //확장 후에 아래 코드를 실행해보자.

            for(let name in o){
                console.log(name);
            }
            //결과 name contain
            /*
            확장한 프로퍼티인 contain이 포함되어 있다.
            객체가 기본적으로 가지고 있을 것으로 예상하고 있는 객체 외에
            다른 객체를 가지고 있는 것은 개발자들에게 혼란을 준다. 
            이 문제를 회피하기 위해서는 프로퍼티의 해당 객체의 
            소속인지를 체크해볼 수 있는 hasOwnProperty를 사용하면 된다. 
            */
            for (let name in o) {
                if (o.hasOwnProperty(name)){
                    console.log(name);
                } 
            }
            //hasOwnProperty는 인자로 전달된 속성의 이름이 객체의 속성인지 여부를 판단한다.
            //만약 prototype으로 상속 받은 객체라면 false가 된다. 
        </script>
    </body>
</html>